# 衔接资产

## 介绍

桥接是通过两个合约来实现的
(一个部署在L1，另一个部署在L2)
使用[L1 <-> L2 interoperability](./l1-l2-interop.md)相互通信。

开发者可以自由地为任何令牌建立自己的桥梁。
然而，我们提供了我们的默认桥接器（一个用于ETH，一个用于ERC20代币），可用于基本桥接。

::: warning

L2上的代币的地址将总是与同一代币L1地址不同。

:::

## 默认桥接

你可以使用`zks_getBridgeContracts`端点或我们的[Javascript SDK](.../.../api/js/)中`Provider`的`getDefaultBridgeAddresses`方法获得默认桥的地址（其他SDK中也有类似方法）。

### 存款(到L2)

用户必须在L1桥梁合约上调用`deposit`方法，这将触发以下动作。

- 用户的L1代币将被发送到L1桥，并在那里被锁定。
- L1桥使用L1->L2通信向L2桥发起一个交易。
- 在L2交易中，代币将被铸造并被发送到L2上的指定地址。
  - 如果该代币在zkSync上还不存在，就会为其部署一个新的合约。鉴于L2代币地址是确定的（基于原始L1地址、名称和符号），谁是第一个桥接它的人并不重要，新的L2地址将是相同的。
- 对于每一个执行的L1->L2事务，都会有一个L2->L1的日志信息来确认其执行。
- 最后，`finalizeDeposit`方法被调用，它最终完成存款并在L2上铸造资金。

:::warning

如果这个交易由于任何原因而失败（例如，提供的费用太低），日志信息将说明其失败。
在这种情况下，可以在L1桥上证明日志的收录，通过调用`claimFailedDeposit`方法将存入的资金返还给原发件人。

:::

上面描述的日志信息还没有被我们的SDK完全支持，但在L1桥的合约上可以使用。

### 提款(到L1)

用户必须调用L2桥接合约上的`withdraw`方法，这将触发以下动作。

- L2代币将被烧毁。
- 将发送一条包含提款信息的L2->L1消息。
- 之后，提款行动将可由 L1 桥中的任何人完成（通过证明包含 L2 -> L1 消息，这在调用 L1 桥合约上的 `finalizeWithdraw` 方法时完成）。
- 在该方法被调用后，资金从L1桥中解锁并发送给提款接收人。

:::warning

在testnet环境下，我们会自动敲定所有的提款，也就是说，对于每一笔提款，我们都会通过做L1交易来处理，证明每条信息的包含。

:::
